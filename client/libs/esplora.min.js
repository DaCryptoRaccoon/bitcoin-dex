/**********************************************************************
 * Copyright (c) 2019 Robin Linus                                     *
 * Distributed under the MIT software license, see                    *
 * http://www.opensource.org/licenses/mit-license.php.                *
 **********************************************************************/


/*
    Simple Esplora Client

    See Blockstream API Documentation
        https://github.com/Blockstream/esplora/blob/master/API.md

    Features: 
        - Mainnet & Testnet
        - Error Handling
        - Documentation
        - No Dependencies
        - Compatible with tree shaking
        - Error Handling API
        - most endpoints implemented
*/


// Base URI of the Esplora Server API endpoint (mainnet)
const BASE_URI_MAINNET = `https://blockstream.info/api`;

// Base URI of the Esplora Server API endpoint (testnet)
const BASE_URI_TESTNET = `https://blockstream.info/testnet/api`;

// Base URI
let BASE_URI = BASE_URI_MAINNET;

function useTestnet() {
    BASE_URI = BASE_URI_TESTNET;
}


/**
 * Assert a HTTP response is OK. Otherwise throw an error with the server's error message.
 * 
 * @param {Response} response 
 * @return Promise<void>
 *
 * @example
 *
 *     assertOK(await fetch('/'))
 */
async function assertOK(response) {
    if (response.ok) return; // response is OK thus nothing to do.
    let message = await response.text();
    throw new EsploraError(message);
}

/**
 * Get information about an address 
 *
 * @param {string} address 
 * @return {object} {chain_stats, mempool_stats}
 *
 * @example
 *
 *     fetchAddressInfo('17A16QmavnUfCW11DAApiJxp7ARnxN5pGX')
 */
async function fetchAddressInfo(address) {
    const response = await fetch(`${ BASE_URI }/address/${address}`);
    await assertOK(response);
    return response.json();
}


/**
 * Broadcast a raw transaction to the network.
 * The transaction should be provided as hex.
 * The txid will be returned on success.
 *
 * @param {string} rawTransaction 
 * @return {string} transaction id
 *
 * @example
 *
 *     broadcastTransaction('<<raw transaction in hex>>')
 */
async function broadcastTransaction(rawTransaction) {
    const response = await fetch(
        `${BASE_URI}/tx`, {
            method: 'POST',
            body: rawTransaction
        }
    );
    await assertOK(response);
    return response.text();
}

/**
 * Get the list of unspent transaction outputs associated with the address.
 *
 * @param {string} address 
 * @return {object} { chain_stats, mempool_stats }
 *
 * @example
 *
 *     fetchUnspentOutputs('17A16QmavnUfCW11DAApiJxp7ARnxN5pGX')
 */
async function fetchUnspentOutputs(address) {
    const response = await fetch(`${ BASE_URI }/address/${address}/utxo`);
    await assertOK(response);
    return response.json();
}


/**
 * Returns information about the transaction.
 *
 * @param {string} txid 
 * @return {object} transaction
 *
 * @example
 *
 *     fetchTransaction('2b19a7287581da86de256536fb6ba1be1347bd6dd62a899e965b44374fdebfec')
 */
async function fetchTransaction(txid) {
    const response = await fetch(`${ BASE_URI }/tx/${ txid }`);
    await assertOK(response);
    return response.json();
}



/**
 * Returns information about the transaction's outspends.
 *
 * @param {string} txid 
 * @return {object} transaction outspends
 *
 * @example
 *
 *     fetchTransactionOutspends('2b19a7287581da86de256536fb6ba1be1347bd6dd62a899e965b44374fdebfec')
 */
async function fetchTransactionOutspends(txid) {
    const response = await fetch(`${ BASE_URI }/tx/${ txid }/outspends`);
    await assertOK(response);
    return response.json();
}



/**
 * Get balance of an address in Satoshis
 *
 * @param {string} address 
 * @return { confirmed: Number, unconfirmed: Number } balance
 * 
 * @example
 *
 *     fetchBalance('17A16QmavnUfCW11DAApiJxp7ARnxN5pGX')
 */
async function fetchBalance(address) {
    const addressInfo = await fetchAddressInfo(address);

    const confirmed = statsToBalance(addressInfo.chain_stats);
    const unconfirmed = statsToBalance(addressInfo.mempool_stats);
    const total = confirmed + unconfirmed;

    return { confirmed, unconfirmed, total };
}

function statsToBalance(stats) {
    const totalReceived = stats.funded_txo_sum;
    const totalSent = stats.spent_txo_sum;
    const balance = totalReceived - totalSent;
    return balance;
}



/**
 * Get transaction history for the specified address, sorted with newest first.
 *
 * @param {string} address 
 * @return {object} transactions
 *
 * @example
 *
 *     fetchTransactions('17A16QmavnUfCW11DAApiJxp7ARnxN5pGX')
 */
async function fetchTransactions(address) {
    const response = await fetch(`${ BASE_URI }/address/${ address }/txs`);
    await assertOK(response);
    return response.json();
}


/**
 * Set of error codes of the esplora API
 *
 */
const ErrorCode = {
    UNKNOWN: 1000000,
    MISSING_INPUTS: -25
};

/**
 * Parse Esplora API errors
 *
 */
class EsploraError extends Error {

    constructor(message) {
        // Parse RPC error name
        let name = message.match(/^.* RPC error/);
        if (name) name = name[0];

        // Clean up RPC error response to parse the JSON
        message = message.replace(/^.* RPC error: /, '');

        let code = ErrorCode.UNKNOWN;

        // try to parse the response as JSON
        try {
            message = JSON.parse(message);
            code = message.code;
            message = message.message;
        } catch (e) {
            // can not parse JSON. Thus, we treat the response as plain text. 
        }

        // Initialization
        super(message);
        this.name = name || 'Esplora Error';
        this.code = code;
    }
}

const Esplora = {
	useTestnet,
	fetchTransaction,
	broadcastTransaction,
	fetchUnspentOutputs,
	fetchBalance,
    fetchTransactionOutspends,
    fetchTransactions
};



